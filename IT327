import java.util.*;
import java.util.Stack;

/**
 * Josh Foster IT 327 LL1 Parser Assignment 9/17/2019 LL1
 * E -> TE' 
 * E' -> +TE'
 * E'-> -TE' 
 * E'-> empty
 * T -> FT' 
 * T'-> *FT' 
 * T' -> /FT' 
 * T'-> empty 
 * F -> (E) 
 * F - > n
 * 
 * 
 * ==============================================================================
 * n + - * / ( ) $
 * --------------------------------------------------------------------------------
 * E| E->T->TE' | | | | | T->TE' |
 * ------------------------------------------------------------------------------
 * E'| | E'->+TE' | E'->-TE' | | | E'->empty| |E'->empty
 * --------------------------------------------------------------------------------
 * T| T-> FT' | | | |T-> FT' | |
 * --------------------------------------------------------------------------------
 * E'| | T'->empty|T'->empty | T'->FT' | T'->/FT'|T'->empty | T'->empty
 * -------------------------------------------------------------------- F| F->n
 * | | | | F->(E) | |
 * ---------------------------------------------------------------------------------
 * ===============================================================================
 */
public class LL1 {
	// create new Scanner object to get input from user
	static Scanner console = new Scanner(System.in);

	public String input = "";// String for expression input from user
	private int indexOfInput = -1;

	// Stack to hold tokens and rules to compare
	Stack<String> stack = new Stack<String>();

	// Table for grammar/rules
	String[][] table = {
			// FOR SIMPLICITY IN PROGRAMMING E' = K and T'= G
			{ "TK", null, null, null, null, "TK", null, null }, { null, "+TK", "-TK", null, null, null, "", "" },
			{ "FG", null, null, null, null, "FG", null, null }, { null, "", "", "*FG", "/FG", null, "", "" },

			{ "n", null, null, null, null, "(E)", null, null }

	};
	// arrays to hold valid terminal symbols and non-terminal symbols
	String[] nonTers = { "E", "K", "T", "G", "F" };
	String[] terminals = { "n", "+", "-", "*", "/", "(", ")", "$" };

	// constructor
	public LL1(String in) {
		this.input = in;
	}

	private void pushRule(String rule) {
		for (int i = rule.length() - 1; i >= 0; i--) {
			char ch = rule.charAt(i);
			String str = String.valueOf(ch);
			push(str);
		}
	}// end of pushRule

	// parsing algorithm
	public void algorithm() {

		// push the first token and the first grammar rule onto the stack
		push(this.input.charAt(0) + "");//
		push("E");

		// Read one token from input

		String token = read();
		String top = null;

		do {
			top = this.pop();

			// if top element in the stack is non-terminal consult the parsing table to get rule
			if (isNonTerminal(top)) {
				String rule = this.getRule(top, token);
				this.pushRule(rule);
			} else if (isTerminal(top)) {
				if (!top.equals(token)) {
					error("this token is not correct , By Grammer rule . Token : (" + token + ")");
				} else {

					token = read();

				}
			} else {
				error("Never Happens , Because top : ( " + top + " )");
			}
			if (token.equals("$")) {
				break;
			}
			//continue looping until end of expression ($) is found

		} while (true);// out of the loop when $

		if (token.equals("$")) {
			System.out.println("Input is Accepted by LL1 parser");
		} else {
			System.out.println("Input is not Accepted by LL1 parser");
		}
	}//end of algorithm

	private boolean isTerminal(String s) {
		for (int i = 0; i < this.terminals.length; i++) {
			if (s.equals(this.terminals[i])) {
				return true;
			}

		}
		return false;
	}

	private boolean isNonTerminal(String s) {
		for (int i = 0; i < this.nonTers.length; i++) {
			if (s.equals(this.nonTers[i])) {
				return true;
			}

		}
		return false;
	}

	private String read() {
		indexOfInput++;
		char ch = this.input.charAt(indexOfInput);
		String str = String.valueOf(ch);

		return str;
	}

	private void push(String s) {
		this.stack.push(s);
	}

	private String pop() {
		return this.stack.pop();
	}

	private void error(String message) {
		System.out.println(message);
		throw new RuntimeException(message);
	}

	public String getRule(String non, String term) {

		int row = getnonTermIndex(non);
		int column = getTermIndex(term);
		String rule = this.table[row][column];

		if (rule == null) {
			System.out.println("This input it is not accepted by LL1 Parser");

		}
		return rule;
	}

	private int getnonTermIndex(String non) {
		for (int i = 0; i < this.nonTers.length; i++) {
			if (non.equals(this.nonTers[i])) {
				return i;
			}
		}
		error(non + " is not NonTerminal");
		return -1;
	}

	private int getTermIndex(String term) {
		for (int i = 0; i < this.terminals.length; i++) {
			if (term.equals(this.terminals[i])) {
				return i;
			}
		}
		error(term + " is not Terminal");
		return -1;
	}

	// method to convert numbers into a single char for the parser to read
	private static String convertDigits(String input) {
		// in this method we wont to convert all digits to a single char.. we do
		// not care about the values since we are not calculating the result of
		// expression

		// Since String is immutable..convert String into String Builder so that
		// we can modify characters
		StringBuilder inputString = new StringBuilder(input);

		// convert all digits in the input String to the character n
		for (int i = 0; i < inputString.length(); i++) {
			if (Character.isDigit(inputString.charAt(i)))
				inputString.setCharAt(i, 'n');
		} // end of for loop

		int pointer = 0;// set pointer for loop

		// iterate through the characters to remove consecutive digits ('nn'-->
		// 'n') for parser to read expression
		while (pointer < inputString.length() - 1) {

			if (inputString.charAt(pointer) == 'n' && inputString.charAt(pointer + 1) == 'n')
				inputString.deleteCharAt(pointer); // delete consecutive
													// characters for parser
			else
				pointer++;

		} // end of while

		return inputString + "";
	}// end of convertDigits method

	// Driver code
	public static void main(String[] args) {

		String inputString = "";
		System.out.println("Enter expression:\n");

		//add $ to the end of string to let program know the end of the expression
		inputString = console.next() + "$";
		
		//convert all digits to char ('n')
		inputString = convertDigits(inputString);
		System.out.println(inputString);
		
		//create LL1 object to use methods on input string
		LL1 parser = new LL1(inputString);
		parser.algorithm();

	}// end of main method

}// end of ll1 class
